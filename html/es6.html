<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="Shortcut Icon" href="../images/icon01.png" />
    <link rel="stylesheet" href="../css/index.css">
    <title>ES6</title>
    <style>
        span{
            height: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://libs.baidu.com/jquery/2.0.0/jquery.js"></script>
    <script>
       $(function () {
           $('i').on('click',function () {
               if($(this).hasClass('active')){
                   $(this).removeClass('active');
                   $(this).text('+');
                   $(this).next('span').css({
                       'height':'0',
                       'overflow':'hidden'
                   })
               }else{
                   $(this).addClass('active');
                   $(this).text('-');
                   $(this).next('span').css({
                       'height':'auto',
                       'overflow':'auto'
                   })
               }
           })
           $('h6').on('click',function () {
               if($(this).hasClass('active')){
                   $(this).removeClass('active');
                   $(this).parent('li').removeClass('active')
               }else{
                   $(this).addClass('active');
                   $(this).parent('li').addClass('active')
               }
           })

           $('img').parent('span').css({
               'padding-left':0,
               'background':'none'
           })
       })
    </script>
</head>
<body style=" background: url(../images/back01.png)repeat">
<div class="header"><h1></h1></div>
<div class="inner">
    <div class="msg-box">
        <div class="msg">
            <div class="title">2017年11月19日 星期日</div>
            <h3>ES6</h3>
            <div class="font">
                <div class="size">
                    <h4>技术简介 :</h4>
                    <h6>ES6</h6>
                    ESMAscript6.0(简称ES6)，是继ESMAscript5.1之后的下一代Javascript语言的下一代标准，发布在2015年6月，它的目标是用JavaScript语言来编写复杂的大型应用程序，成为企业级开发语言。
                    <ul>
                        <li>
                            <h6>一、let命令</h6>
                            1、使用let命令声明的变量，只有在代码块里有效<br>
                            2、使用let变量不会被提升<br>
                            3、暂时性死区（只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响）；
                            <i>+</i>
                            <span>
                               let f = 10;  <br>
                                function fn() {<br>
                                 &nbsp;&nbsp;   f = 7;<br>
                                 &nbsp;&nbsp;  let f = 2;<br>
                                }<br>
                                fn() //error
                        </span>
                            4、在同一作用域下不允许声明已经存在的变量<br>
                            5、let在循环语句的应用<br>
                            变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量
                            <i>+</i>
                            <span>
                            var a = [];<br>
                            for (let i = 0; i < 10; i++) {<br>
                             &nbsp;&nbsp; a[i] = function () {<br>
                               &nbsp;&nbsp;&nbsp;&nbsp; console.log(i);<br>
                              &nbsp;&nbsp;};<br>
                            }<br>
                            a[6](); // 6<br>
                        </span>
                            6、在循环语句之内是一个父作用域、而在循环体之中是一个子作用域
                            <br>(let声明的变量不会泄露到作用域之外的)
                            <i>+</i>
                            <span>

                           for (let i=0;i<9;i++)//父作用域{ <br>
                        &nbsp;&nbsp;let i =10;       //子作用域<br>
                        &nbsp;&nbsp;console.log(i)//3次10<br>
                            }<br>
                               </span>
                        </li>
                        <li>
                            <h6> 二、const命令 常量<br></h6>
                            const命令同样有let的1/2/3特点，<br>
                            1、所声明的变量只在其所在的代码块里有效<br>
                            2、声明的变量不会被提升<br>
                            3、不能声明已经被声明过的变量<br>
                            4、声明的时候必须赋值<br>
                            5、声明的常量在简单的数据类型的时候不可改变其值，如果储存的是对象，
                            那么引用不可以被改变，只有对象里面的数据如何变化，是没有关系的
                            <i>+</i>
                            <span>
                            //对象<br>
                            const a = 1;<br>
                            a = {};//error<br>
                            const obj = {a:10};<br>
                            obj.a = 20;<br>
                            console.log(obj);// a = 20;<br>
                            const a = [];<br>
                            //数组<br>
                            a.push('Hello'); // 可执行<br>
                            a.length = 0;    // 可执行<br>
                            a = ['Dave'];    // 报错<br>
                        </span>
                        </li>
                        <li>
                            <h6>三、解构赋值</h6>
                            ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构<br>
                            1、变量赋值<br>
                            可以从数组中提取值，按照对应位置，对变量赋值。只要等号两边的模式相同，左边的变量就会被赋予对应的值。
                            <i>+</i>
                            <span>let [a, b, c] = [1, 2, 3];</span>
                            2、嵌套数组进行解构
                            <i>+</i>
                            <span>
                        let [foo, [[bar], baz]] = [1, [[2], 3]];<br>
                        foo // 1<br>
                        bar // 2<br>
                        baz // 3<br>
                        &nbsp;<br>
                        let [ , , third] = ["foo", "bar", "baz"];<br>
                        third // "baz"<br>
                                   &nbsp;<br>
                        let [x, , y] = [1, 2, 3];<br>
                        x // 1<br>
                        y // 3<br>
                         &nbsp;<br>
                        let [head, ...tail] = [1, 2, 3, 4];<br>
                        head // 1<br>
                        tail // [2, 3, 4]<br>
                         &nbsp;<br>
                        let [x, y, ...z] = ['a'];<br>
                        x // "a"<br>
                        y // undefined<br>
                        z // []<br>
                        </span>
                            如果解构不成功，变量的值就等于undefined。<br>
                            3、默认值<br>
                            解构赋值允许指定默认值。
                            <i>+</i>
                            <span>
                            let [foo = true] = [];<br>
                            foo // true<br>

                            let [x, y = 'b'] = ['a']; // x='a', y='b'<br>
                            let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'<br>
                        </span>
                            注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。
                            <i>+</i>
                            <span>
                            let [x = 1] = [undefined];<br>
                            x // 1<br>
                            let [x = 1] = [null];<br>
                            x // null<br>
                        </span>
                            上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。
                            <i>+</i>
                            <span>
                            let [x = 1, y = x] = [];     // x=1; y=1<br>
                            let [x = 1, y = x] = [2];    // x=2; y=2<br>
                            let [x = 1, y = x] = [1, 2]; // x=1; y=2<br>
                            let [x = y, y = 1] = [];     // ReferenceError<br>
                        </span>
                            上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。<br>
                            4、对象的解构赋值<br>
                            解构不仅可以用于数组，还可以用于对象。
                            <i>+</i>
                            <span>
                            let { foo, bar } = { foo: "aaa", bar: "bbb" };<br>
                            foo // "aaa"<br>
                            bar // "bbb<br>
                        </span>
                            对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
                            <i>+</i>
                            <span>
                            let { bar, foo } = { foo: "aaa", bar: "bbb" };<br>
                            foo // "aaa"<br>
                            bar // "bbb"<br>
                            &nbsp;<br>
                            let { baz } = { foo: "aaa", bar: "bbb" };<br>
                            baz // undefined<br>
                            // 没有对应的同名属性，导致取不到值，最后等于undefin   ed。<br>
                        </span>
                            如果变量名与属性名不一致
                            <i>+</i>
                            <span>
                            let { foo: baz } = { foo: 'aaa', bar: 'bbb' };<br>
                            baz // "aaa"
                        </span>
                            也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

                            <i>+</i>     <span>
                            let { foo: baz } = { foo: "aaa", bar: "bbb" };<br>
                            baz // "aaa"<br>
                            foo // error: foo is not defined<br>
                        </span>
                            上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。<br>
                            5、对象的解构也可以指定默认值。
                            <i>+</i>    <span>
                            var {x = 3} = {};<br>
                            x // 3<br>

                            var {x, y = 5} = {x: 1};<br>
                            x // 1<br>
                            y // 5<br>

                            var {x: y = 3} = {};<br>
                            y // 3<br>

                            var {x: y = 3} = {x: 5};<br>
                            y // 5<br>
                        </span>
                            6、默认值生效的条件是，对象的属性值严格等于undefined。
                            <i>+</i>   <span>
                        var {x = 3} = {x: undefined};<br>
                        x // 3<br>

                        var {x = 3} = {x: null};<br>
                        x // null<br>
                        </span>
                            7、数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
                            <i>+</i>  <span>
                            let arr = [1, 2, 3];<br>
                            let {0 : first, [arr.length - 1] : last} = arr;<br>
                            first // 1<br>
                            last // 3<br>
                        </span>
                            上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。

                        </li>
                        <li>
                            <h6>四、字符串解构赋值</h6>
                            字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
                            <i>+</i>
                            <span>
                            const [a, b, c, d, e] = 'hello';<br>
                            a // "h"<br>
                            b // "e"<br>
                            c // "l"<br>
                            d // "l"<br>
                            e // "o"<br>
                        </span>
                            类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
                            <i>+</i>
                            <span>
                            let {length : len} = 'hello';<br>
                            len // 5<br>
                        </span>
                        </li>
                        <li>
                            <h6>五、数值和布尔值的解构赋值</h6>
                            解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
                            <i>+</i>
                            <span>
                            let {toString: s} = 123;<br>
                            s === Number.prototype.toString // true<br>

                            let {toString: s} = true;<br>
                            s === Boolean.prototype.toString // true<br>
                        </span>
                            上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。
                            <i>+</i>
                            <span>
                            let { prop: x } = undefined; // TypeError<br>
                            let { prop: y } = null; // TypeError<br>
                        </span>
                            解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

                        </li>
                        <li>
                            <h6>六、函数参数的解构赋值</h6>
                            函数的参数也可以使用解构赋值。
                            <i>+</i>
                            <span>
                            function add([x, y]){<br>
                              return x + y;<br>
                            }<br>
                            add([1, 2]); // 3
                        </span>
                            函数参数的解构也可以使用默认值。
                            <i>+</i>
                            <span>
                            function move({x = 0, y = 0} = {}) {<br>
                             &nbsp;&nbsp; return [x, y];<br>
                            }<br>

                            move({x: 3, y: 8}); // [3, 8]<br>
                            move({x: 3}); // [3, 0]<br>
                            move({}); // [0, 0]<br>
                            move(); // [0, 0]<br>
                        </span>
                        </li>
                        <li>
                            <h6>七、用途</h6>
                            变量的解构赋值用途很多。<br>
                            (1)、变化变量的值
                            <i>+</i>
                            <span>
                            let x = 1;<br>
                            let y = 2;<br>
                            [x,y]=[y,x];<br>
                        </span>
                            上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。
                            <br>(2)、从函数返回多个值<br>
                            函数只能返回一个值，如果要返回多个值，只能将它们放在数组和对象里返回。有了解构赋值，取这些值就非常方便。
                            <br>
                            <i>+</i>
                            <span>
                            //返回一个数组<br>
                            function example(){<br>
                                return [1,2,3]<br>
                            }<br>
                            let [a,b,c] = example();<br>
                            //返回一个对象<br>
                            function example(){<br>
                              &nbsp;&nbsp;return{<br>
                              &nbsp;&nbsp;&nbsp;&nbsp;foo:1,<br>
                              &nbsp;&nbsp;&nbsp;&nbsp;bar:2<br>
                              &nbsp;&nbsp;};<br>
                            }<br>
                            let {foo,bar} = example();
                        </span>
                            (3)、函数参数的定义<br>
                            解构赋值可以方便地将一组参数与变量名对应起来。
                            <i>+</i>
                            <span>
                            // 参数是一组有次序的值<br>
                            function f([x, y, z]) { ... }<br>
                            f([1, 2, 3]);<br>

                            // 参数是一组无次序的值<br>
                            function f({x, y, z}) { ... }<br>
                            f({z: 3, y: 2, x: 1});<br>
                        </span>
                            (4)、提取JSON数据<br>
                            解构赋值对提取JSON对象中的数据，尤其有用
                            <i>+</i>
                            <span>
                            let jsonData = {<br>
                             &nbsp;&nbsp;id: 42,<br>
                              &nbsp;&nbsp;status: "OK",<br>
                              &nbsp;&nbsp;data: [867, 5309]<br>
                            };<br>

                            let { id, status, data: number } = jsonData;<br>

                            console.log(id, status, number);<br>
                            // 42, "OK", [867, 5309]<br>
                        </span>
                            (5)、函数参数的默认值<br>
                            <i>+</i>
                            <span>
                            jQuery.ajax = function (url, {<br>
                               &nbsp;&nbsp;async = true,<br>
                               &nbsp;&nbsp;beforeSend = function () {},<br>
                               &nbsp;&nbsp;cache = true,<br>
                               &nbsp;&nbsp;complete = function () {},<br>
                               &nbsp;&nbsp;crossDomain = false,<br>
                               &nbsp;&nbsp;global = true,<br>
                               &nbsp;&nbsp;// ... more config<br>
                            }) {<br>
                               &nbsp;&nbsp;// ... do stuff<br>
                            };<br>
                        </span>
                            (6)、遍历Map解构<br>
                            任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。
                            <i>+</i>  <span>
                            const map = new Map();<br>
                            map.set('first', 'hello');<br>
                            map.set('second', 'world');<br>
                            <br>
                            for (let [key, value] of map) {<br>
                              console.log(key + " is " + value);<br>
                            }<br>
                            // first is hello<br>
                            // second is world<br>
                        </span>
                            如果只想获取键名，或者只想获取键值，可以写成下面这样。
                            <i>+</i> <span>
                            // 获取键名<br>
                            for (let [key] of map) {<br>
                              // ...<br>
                            }<br>

                            // 获取键值<br>
                            for (let [,value] of map) {<br>
                              // ...<br>
                            }<br>
                        </span>
                            (7)、输入模块的指定方法<br>
                            加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
                            <i>+</i> <span>
                            const { SourceMapConsumer, SourceNode } = require("source-map");
                        </span>
                        </li>
                        <li>
                            <h6>八、字符串扩展</h6>
                              1、  ES6为字符串添加了遍历器接口，使得字符串可以被for.....of循环遍历
                            <i>+</i>
                            <span>
                                for (let i of 'foo') {<br>
                                &nbsp;&nbsp;console.log(i)<br>
                                }<br>
                                // "f"<br>
                                // "o"<br>
                                // "o"<br>
                            </span>
                            2、includes(), startsWith(), endsWith()<br>
                            JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中<br>
                            includes()：返回布尔值，表示是否找到了参数字符串。<br>
                            startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>
                            endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>
                            <i>+</i>
                            <span>
                                let s = 'Hello world!';<br>
                                s.includes('o') // true<br>
                                s.startsWith('Hello') // true<br>
                                s.endsWith('H') // true<br>
                            </span>
                            这三个方法都支持第二个参数，表示开始搜索的位置。
                            <i>+</i>
                            <span>
                                let s = 'Hello world!';<br>
                                s.startsWith('world', 6) // true<br>
                                s.endsWith('Hello', 5) // true<br>
                                s.includes('Hello', 6) // false<br>
                            </span>
                            使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。
                            <br>3、repeat()<br>
                            repeat方法返回一个新字符串，表示将原字符串重复n次。
                            <i>+</i>
                            <span>
                                'x'.repeat(3) // "xxx"<br>
                                'hello'.repeat(2) // "hellohello"<br>
                                'na'.repeat(0) // ""<br>
                            </span>
                            参数如果是小数，会被取整。
                            <i>+</i>
                            <span>
                                'na'.repeat(2.9) // "nana"
                            </span>
                            如果repeat的参数是负数或者Infinity，会报错。
                            <i>+</i>
                            <span>
                                'na'.repeat(Infinity)<br>
                                // RangeError<br>
                                'na'.repeat(-1)<br>
                                // RangeError<br>
                            </span>
                            但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。
                            <i>+</i>
                            <span>'na'.repeat(-0.9) // ""</span>
                            参数NaN等同于 0。
                            <i>+</i>
                            <span>
                            'na'.repeat(NaN) // ""
                            </span>
                            如果repeat的参数是字符串，则会先转换成数字。
                            <i>+</i>
                            <span>'na'.repeat('na') // ""<br>
                                    'na'.repeat('3') // "nanana"
                            </span>
                            4、padStart()，padEnd()<br>
                            ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
                            <i>+</i>
                            <span>
                                'x'.padStart(5, 'ab') // 'ababx'<br>
                                'x'.padStart(4, 'ab') // 'abax'<br>

                                'x'.padEnd(5, 'ab') // 'xabab'<br>
                                'x'.padEnd(4, 'ab') // 'xaba'<br>
                            </span>
                             (1)如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串<br>
                             (2) 如果省略第二个参数，默认使用空格补全长度<br>
                             (3) padStart的常见用途为数值补全指定位数
                            <i>+</i>
                            <span>
                                '1'.padStart(10, '0') // "0000000001"<br>
                                '12'.padStart(10, '0') // "0000000012"<br>
                                 '123456'.padStart(10, '0') // "0000123456"<br>
                            </span>
                            (4)另一个用途是提示字符串格式。
                            <i>+</i>
                            <span>
                                '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"<br>
                                '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
                            </span>
                            5、模板字符串<br>
                           (1) 传统的JavaScript语言，输出模板通常是这样写的。
                            <i>+</i>
                            <span>
                                $('#result').append(<br>
                                  &nbsp;&nbsp;'There are <b>' + basket.count + '</b> ' +<br>
                                  &nbsp;&nbsp;'items in your basket, ' +<br>
                                  &nbsp;&nbsp;'<em>' + basket.onSale +<br>
                                  &nbsp;&nbsp;'</em> are on sale!'<br>
                                );
                            </span>
                            上面这种写法相当繁琐不方便、ES6 引入了模板字符串解决这个问题。<br>
                            <i>+</i>
                            <span>
                                $('#result').append(`<br>
                                  &nbsp;&nbsp;There are <b>${basket.count}</b> items<br>
                                  &nbsp;&nbsp;in your basket, <em>${basket.onSale}</em><br>
                                  &nbsp;&nbsp;are on sale!<br>
                                `);<br>
                            </span>
                            (2) 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
                            <i>+</i>
                            <span>
                                // 普通字符串<br>
                                `In JavaScript '\n' is a line-feed.`<br>

                                // 多行字符串<br>
                                `In JavaScript this is<br>
                                 not legal.`<br>

                                console.log(`string text line 1<br>
                                string text line 2`);<br>

                                // 字符串中嵌入变量<br>
                                let name = "Bob", time = "today";<br>
                                `Hello ${name}, how are you ${time}?`<br>
                            </span>
                            上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。
                            <i>
                                +
                            </i>
                            <span>
                                let greeting = `\`Yo\` World!`;
                            </span>
                            (3) 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。
                            <i>+</i>
                            <span>
                                $('#list').html(`<br>
                                    &nbsp;&nbsp;< ul><br>
                                    &nbsp;&nbsp;< li>first< /li><br>
                                    &nbsp;&nbsp;< li>second< /li><br>
                                    &nbsp;&nbsp;< /ul><br>
                                 `);
                            </span>
                            上面的代码模板字符串的空格和换行、都是会保留的，如果你不想换行，可以用trim方法消除它
                            <i>+</i>
                            <span>
                                     $('#list').html(`<br>
                                    &nbsp;&nbsp;< ul><br>
                                    &nbsp;&nbsp;< li>first< /li><br>
                                    &nbsp;&nbsp;< li>second< /li><br>
                                    &nbsp;&nbsp;< /ul><br>
                                   `).trim());
                            </span>
                            (4) 模板字符串中嵌入变量，需要将变量名写在${}之中。 <br>
                            (5) 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性<br>
                            <i>+</i>
                            <span>
                            let x = 1;<br>
                            let y = 2;<br>

                            `${x} + ${y} = ${x + y}`<br>
                            // "1 + 2 = 3"<br>

                            `${x} + ${y * 2} = ${x + y * 2}`<br>
                            // "1 + 4 = 5"<br>

                            let obj = {x: 1, y: 2};<br>
                            `${obj.x + obj.y}`<br>
                            // "3"<br>
                            </span>
                            (6)模板字符串之中还能调用函数
                            <i>+</i>
                            <span>
                                function fn() {<br>
                                 &nbsp;&nbsp;return "Hello World";<br>
                                }<br>
                                `foo ${fn()} bar`<br>
                                // foo Hello World bar<br>
                            </span>
                            (7)如何字符串里的变量没有声明，将报错
                            <i>+</i>
                            <span>
                                   // 变量place没有声明<br>
                                    let msg = `Hello, ${place}`;<br>
                                    // 报错<br>
                            </span>
                            (8) 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。
                            <i>+</i>
                            <span>
                                `Hello ${'World'}`
                                // "Hello World"
                            </span>
                            (9)模板字符串甚至还能嵌套。
                            <i>+</i>
                            <span>
                                 const tmpl = addrs => ` <br>
                                  < table> <br>
                                  ${addrs.map(addr => ` <br>
                                    < tr>< td>${addr.first}< /td>< /tr> <br>
                                    < tr>< td>${addr.last}< /td>< /tr> <br>
                                  `).join('')} <br>
                                  < /table> <br>
                                `
                                const data = [<br>
                                    { first: '< Jane>', last: 'Bond' },<br>
                                    { first: 'Lars', last: '< Croft>' },<br>
                                ];

                                console.log(tmpl(data));<br>
                                // < table><br>
                                //<br>
                                //   < tr>< td>< Jane>< /td>< /tr><br>
                                //   < tr>< td>Bond< /td>< /tr><br>
                                //<br>
                                //   < tr>< td>Lars< /td>< /tr><br>
                                //   < tr>< td>< Croft>< /td>< /tr><br>
                                //<br>
                                // < /table><br>
                            </span>
                            (10)、实例：模板编译
                            在模板字符串之中，放置了一个常规模板。该模板使用<%...%>放置 JavaScript 代码，使用<%= ... %>输出 JavaScript 表达式。
                            <i>+</i>
                            <span>
                                <img src="../images/es6-01.png" alt="">
                            </span>
                            6、标签模板<br>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。
                            <i>+</i>
                            <span>
                                   alert`123`<br>
                                    // 等同于<br>
                                    alert(123)<br>
                            </span>
                            7、String.raw()<br>
                            String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。
                           <i>+</i>
                            <span>
                                String.raw({ raw: 'test' }, 0, 1, 2);<br>
                                // 't0e1s2t'<br>
                                // 等同于<br>
                                String.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);<br>
                            </span>
                        </li>
                        <li>
                            <h6>九、正则的扩展</h6>
                            1、Number.isFinite(), Number.isNaN()<br>
                            Number.isFinite()用来检查一个数值是否为有限的（finite）
                            <i>+</i>
                            <span>
                                <img src="../images/es6-02.png" alt="">
                            </span>
                            Number.isNaN()用来检查一个值是否为NaN。
                            <i>+</i>
                            <span>
                                <img src="../images/es6-03.png" alt="">
                            </span>
                            它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。
                            <br>2、Number.parseInt(), Number.parseFloat()
                            <br>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
                            <i>+</i>
                            <span>
                                <img src="../images/es6-04.png" alt="">
                            </span>
                            这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
                            <i>+</i>
                            <span>
                                Number.parseInt === parseInt // true  <br>
                                Number.parseFloat === parseFloat // true
                            </span>
                            3、Number.isInteger()<br>
                            Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。
                            <i>+</i>
                            <span>
                                Number.isInteger(25) // true<br>
                                Number.isInteger(25.0) // true<br>
                                Number.isInteger(25.1) // false<br>
                                Number.isInteger("15") // false<br>
                                Number.isInteger(true) // false
                            </span>
                            4、Math.trunc()
                            <br>
                            Math.trunc方法用于去除一个数的小数部分，返回整数部分。<br>
                            对于非数值，Math.trunc内部使用Number方法将其先转为数值。<br>
                            对于空值和无法截取整数的值，返回NaN。<br>
                            <i>+</i>
                            <span>
                                Math.trunc(4.1) // 4<br>
                                Math.trunc(-4.9) // -4<br>
                                Math.trunc(-0.1234) // -0<br>
                                Math.trunc('123.456') // 123<br>
                                Math.trunc(true) //1<br>
                                Math.trunc(false) // 0<br>
                                Math.trunc(null) // 0<br>
                                Math.trunc(NaN);      // NaN<br>
                                Math.trunc('foo');    // NaN<br>
                                Math.trunc();         // NaN<br>
                            </span>
                            5、Math.sign()
                            <br>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值
                            <br>它会返回五种值。<br>
                                参数为正数，返回+1；<br>
                                参数为负数，返回-1；<br>
                                参数为 0，返回0；<br>
                                参数为-0，返回-0;<br>
                                其他值，返回NaN。<br>
                               如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN
                            <i>+</i>
                            <span>
                                Math.sign(-5) // -1<br>
                                Math.sign(5) // +1<br>
                                Math.sign(0) // +0<br>
                                Math.sign(-0) // -0<br>
                                Math.sign(NaN) // NaN<br>
                                Math.sign('')  // 0<br>
                                Math.sign(true)  // +1<br>
                                Math.sign(false)  // 0<br>
                                Math.sign(null)  // 0<br>
                                Math.sign('9')  // +1<br>
                                Math.sign('foo')  // NaN<br>
                            </span>
                            6、Math.cbrt()
                            <br>Math.cbrt方法用于计算一个数的立方根。
                            <br>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。
                            <i>+</i>
                            <span>
                                Math.cbrt(-1) // -1<br>
                                Math.cbrt(0)  // 0<br>
                                Math.cbrt(1)  // 1<br>
                                Math.cbrt(2)  // 1.2599210498948734<br>
                                Math.cbrt('8') // 2<br>
                                Math.cbrt('hello') // NaN
                            </span>
                            7、指数运算符
                            <br>ES2016 新增了一个指数运算符（**）。
                            <i>+</i>
                            <span>
                                2 ** 2 =  2 * 2 //4<br>

                                2 ** 3  = 2 * 2 *2 //8<br>
                            </span>
                            指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
                            <i>+</i>
                            <span>
                                let a = 1.5;<br>
                                a **= 2;<br>
                                // 等同于 a = a * a;<br>
                                let b = 4;<br>
                                b **= 3;<br>
                                // 等同于 b = b * b * b;<br>
                            </span>
                        </li>
                        <li class="active">
                            <h6>十、函数的扩展</h6>
                            1、ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
                            <i>+</i>
                             <span>
                                 function log(x, y = 'World') {<br>
                                  &nbsp;&nbsp;console.log(x, y);<br>
                                }<br>
                                log('Hello') // Hello World<br>
                                log('Hello', 'China') // Hello China<br>
                                log('Hello', '') // Hello<br>
                                 <br>
                                 function Point(x = 0, y = 0) {<br>
                                      &nbsp;&nbsp;this.x = x;<br>
                                      &nbsp;&nbsp;this.y = y;<br>
                                    }<br>
                                    const p = new Point();<br>
                                    p // { x: 0, y: 0 }<br>
                             </span>
                            参数变量是默认声明的，所以不能用let或const再次声明。
                            <i>+</i>
                            <span>
                                function foo(x = 5) {<br>
                                  &nbsp;&nbsp;let x = 1; // error<br>
                                  &nbsp;&nbsp;const x = 2; // error<br>
                                }<br>
                            </span>
                            使用参数默认值时，函数不能有同名参数。
                            <br>
                            2、与解构赋值默认值结合使用
                            <i>+</i>
                            <span>
                                <img src="../images/es6-05.png" alt="">
                            </span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>

